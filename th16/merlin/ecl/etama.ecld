sub Et_shootAtRateSync(et del n) {
	var;
	while($n--) {
		Et_shoot($et);
		wait($del);
	}
	return();
}

sub Et_shootAtRate(et del n) {
	var;
	Et_shootAtRateSync($et, $del, $n) async;
	return();
}

/* bullets travel a small distance forward at a fast speed after being shot, then return to normal speed */
sub Et_exDistSet(et channel slot) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_DIST], [NEG], [NEG], [NEGF], [NEGF]);
	return();
}

sub Et_exDist(et channel) {
	var;
	Et_transformPush($et, $channel, [EX_DIST], [NEG], [NEG], [NEGF], [NEGF]);
	return();
}


/* I don't know what this does, Chinese wiki says something about "setting the fog" */
sub Et_exFogSet(et channel slot a) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_FOG], $a, [NEG], [NEGF], [NEGF]);
	return();
}

sub Et_exFog(et channel a) {
	var;
	Et_transformPush($et, $channel, [EX_FOG], $a, [NEG], [NEGF], [NEGF]);
	return();
}


/* bullet accelerates for "a" frames in direction "s", value of acceleration is "s" */
sub Et_exAccelSet(et channel slot a r s) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_ACCEL], $a, [NEG], %r, %s);
	return();
}

sub Et_exAccel(et channel a r s) {
	var;
	Et_transformPush($et, $channel, [EX_ACCEL], $a, [NEG], %r, %s);
	return();
}


/* for "a" frames, bullet  acceleration is set to "r", and angular velocity is "s". */
sub Et_exAngleAccelSet(et channel slot a r s) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_ANGLE_ACCEL], $a, [NEG], %r, %s);
	return();
}

sub Et_exAngleAccel(et channel a r s) {
	var;
	Et_transformPush($et, $channel, [EX_ANGLE_ACCEL], $a, [NEG], %r, %s);
	return();
}

/* something that's related to using this with lasers, I haven't investigated that yet */
sub Et_exAngleAccelLaserSet(et channel slot a b r s) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_ANGLE_ACCEL], $a, $b, %r, %s);
	return();
}

sub Et_exAngleAccelLaser(et channel a b r s) {
	var;
	Et_transformPush($et, $channel, [EX_ANGLE_ACCEL], $a, $b, %r, %s);
	return();
}


/* in "a" frames the bullets will slow down to, and then perform transformation based on "c". This will be repeated "b" times. For the exact function of "c", refer to globals/etama.ecld */
sub Et_exAngleSet(et channel slot a b c r s) {
	var;
	Et_transformSet2($et, $slot, $channel, [EX_ANGLE], $a, $b, $c, [NEG], %r, %s, [NEGF], [NEGF]);
	return();
}

sub Et_exAngle(et channel a b c r s) {
	var;
	Et_transformPush2($et, $channel, [EX_ANGLE], $a, $b, $c, [NEG], %r, %s, [NEGF], [NEGF]);
	return();
}


/* make bullets able to bounce on the sides of the screen. "a" is the amount of bounces, "b" specifies the walls on which the bullet can bounce (use constants from globals/etama.ecld), "r" is speed after bouncing (cen be [NEGF] to retain original speed) */
/* it's also worth noting that the the transformations will stop until the bullet bounced the allowed amount of times, so it can be used to detect when it hits the side of the screen (Okine's first st6 spellcard) */
sub Et_exBounceSet(et channel slot a b r) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_BOUNCE], $a, $b, %r, [NEGF]);
	return();
}

sub Et_exBounce(et channel a b r) {
	var;
	Et_transformPush($et, $channel, [EX_BOUNCE], $a, $b, %r, [NEGF]);
	return();
}

/* this one allows defining custom wall locations, "s" is the distance of the bounce surface from the top/bottom of the screen and "m" is from left/right sides */
sub Et_exBounceCustomSet(et channel slot a b r s m) {
	var;
	Et_transformSet2($et, $slot, $channel, [EX_BOUNCE], $a, $b, [NEG], [NEG], %r, %s, %m, [NEGF]);
	return();
}

sub Et_exBounceCustom(et channel a b r s m) {
	var;
	Et_transformPush2($et, $channel, [EX_BOUNCE], $a, $b, [NEG], [NEG], %r, %s, %m, [NEGF]);
	return();
}



/* makes bullet invulnerable to bombs and such for "a" frames. Does not actually wait for the effect to finish before moving on to the next transform */
sub Et_exInvulnSet(et channel slot a) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_INVULN], $a, [NEG], [NEGF], [NEGF]);
	return();
}

sub Et_exInvuln(et channel a) {
	var;
	Et_transformPush($et, $channel, [EX_INVULN], $a, [NEG], [NEGF], [NEGF]);
	return();
}


/*  I can't get this one to work, supposedly it allows the bullet to leave the screen for "a" frames without getting removed, and role of "b" is unknown */
sub Et_exOffscreenSet(et channel slot a b) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_OFFSCREEN], $a, $b, [NEGF], [NEGF]);
	return();
}

sub Et_exOffscreen(et channel a b) { 
	var;
	Et_transformPush($et, $channel, [EX_OFFSCREEN], $a, $b, [NEGF], [NEGF]);
	return();
}


/* change bullet sprite, basically Et_setSprite($et, $a, $b) */
sub Et_exSpriteSet(et channel slot a b) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_SETSPRITE], $a, $b, [NEGF], [NEGF]);
	return();
}

sub Et_exSprite(et channel a b) {
	var;
	Et_transformPush($et, $channel, [EX_SETSPRITE], $a, $b, [NEGF], [NEGF]);
	return();
}


/* delete bullet, there are 2 graphical effects that can play when deleting the bullet, the one that's used is determined by "a" (either 0 or 1) */
sub Et_exDeleteSet(et channel slot a) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_DELETE], $a, [NEG], [NEGF], [NEGF]);
	return();
}

sub Et_exDelete(et channel a) {
	var;
	Et_transformPush($et, $channel, [EX_DELETE], $a, [NEG], [NEGF], [NEGF]);
	return();
}


/* the bullet plays a sound effect, like playSound($a) */
sub Et_exSoundSet(et channel slot a) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_PLAYSOUND], $a, [NEG], [NEGF], [NEGF]);
	return();
}

sub Et_exSound(et channel a) {
	var;
	Et_transformPush($et, $channel, [EX_PLAYSOUND], $a, [NEG], [NEGF], [NEGF]);
	return();
}


/* same concept as bouncing, except it wraps around to the other side of the screen instead (Seija's midboss card in DDC) */
sub Et_exWrapSet(et channel slot a b r) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_WRAP], $a, $b, %r, [NEGF]);
	return();
}

sub Et_exWrap(et channel a b r) {
	var;
	Et_transformPush($et, $channel, [EX_WRAP], $a, $b, %r, [NEGF]);
	return();
}


/* shoots a bullet
(- is used as a filler) 
Et_aimMode(-, $a);
Et_setCount(-, $c, $d);
Et_setAngle(-, %r, %s);
Et_setSpeed(-, %m, %n);
the spawned bullet will use the same transform list as this one, but will start from index = $b
this also requires the use of the next ins
*/
sub Et_exShootSet(et channel slot a b c d r s m n) {
	var;
	Et_transformSet2($et, $slot, $channel, [EX_SHOOT], $a, $b, $c, $d, %r, %s, %m, %n);
	return();
}

sub Et_exShoot(et channel a b c d r s m n) {
	var;
	Et_transformPush2($et, $channel, [EX_SHOOT], $a, $b, $c, $d, %r, %s, %m, %n);
	return();
}


/* defines properties of the bullet shot by the previous ins
Et_setSprite(-, $a, $b);
$c determines whether the original bullets is deleted or not, 1 means yes, 0 means no
if $c is 1, $d is the bullet deletion effect (like exDelete)

THIS HAS TO BE CALLED AFTER EXSHOOT, NOT BEFORE IT.
*/
sub Et_exDefineShootSet(et channel slot a b c d) {
	var;
	Et_transformSet2($et, $slot, $channel, [EX_DEFINESHOOT], $a, $b, $c, $d, [NEGF], [NEGF], [NEGF], [NEGF]);
	return();
}

sub Et_exDefineShoot(et channel a b c d) {
	var;
	Et_transformPush2($et, $channel, [EX_DEFINESHOOT], $a, $b, $c, $d, [NEGF], [NEGF], [NEGF], [NEGF]);
	return();
}

/* a version to be used with laser-shooting transformation, needs investigation */
sub Et_exDefineLaserSet(et channel slot a b c d r s m n) {
	var;
	Et_transformSet2($et, $slot, $channel, [EX_DEFINESHOOT], $a, $b, $c, $d, %r, %s, %m, %n);
	return();
}

sub Et_exDefineLaser(et channel a b c d r s m n) {
	var;
	Et_transformPush2($et, $channel, [EX_DEFINESHOOT], $a, $b, $c, $d, %r, %s, %m, %n);
	return();
}


/* this works differently in every game lmao (generally used to make bullets react to the player, hence the name)
refer to snowman (HSiFS), graze inferno (LoLK), wall of issun (DDC), possibly Miko's final in TD
 */
sub Et_exReactSet(et channel slot a) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_REACT], $a, [NEG], [NEGF], [NEGF]);
	return();
}

sub Et_exReact(et channel a) {
	var;
	Et_transformPush($et, $channel, [EX_REACT], $a, [NEG], [NEGF], [NEGF]);
	return();
}


/* immidiately jump to transformation number "a", "b" is used to control the number of loops (th16+ only?) */
sub Et_exJumpSet(et channel slot a b) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_GOTO], $a, $b, [NEGF], [NEGF]);
	return();
}

sub Et_exJump(et channel a b) {
	var;
	Et_transformPush($et, $channel, [EX_GOTO], $a, $b, [NEGF], [NEGF]);
	return();
}


/* in "a" frames using mode "b", move the bullet to absolute coordinates (r, s). Mode is the same as for functions such as Move_posTime */
sub Et_exMoveSet(et channel slot a b r s) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_MOVE], $a, $b, %r, %s);
	return();
}

sub Et_exMove(et channel a b r s) {
	var;
	Et_transformPush($et, $channel, [EX_MOVE], $a, $b, %r, %s);
	return();
}


/* immidiately change bullet angle to "r" and bullet speed to "s" */
sub Et_exVelSet(et channel slot r s) {
	var;
	Et_transformSet($et, $slot, $channel, [EX_VEL], [NEG], [NEG], %r, %s);
	return();
}

sub Et_exVel(et channel r s) {
	var;
	Et_transformPush($et, $channel, [EX_VEL], [NEG], [NEG], %r, %s);
	return();
}


/* adds velocity to bullet, angle=r speed=s
this also affects the flow of the transformation list, which is determined by "a", I'm not sure how. Making "a" non-positive seems to cause infinite transformation loop and freeze the game */
sub Et_exVelAddSet(et channel slot a r s) { 
	var;
	Et_transformSet($et, $slot, $channel, [EX_VELADD], $a, [NEG], %r, %s);
	return();
}

sub Et_exVelAdd(et channel a r s) {
	var;
	Et_transformPush($et, $channel, [EX_VELADD], $a, [NEG], %r, %s);
	return();
}


/* sets bullet brightness effect, a=0 normal, a=1 bright, a=2 dark (th16+ only?) */
sub Et_exBrightSet(et channel slot a) { 
	var;
	Et_transformSet($et, $slot, $channel, [EX_BRIGHT], $a, [NEG], [NEGF], [NEGF]);
	return();
}

sub Et_exBright(et channel a) {
	var;
	Et_transformPush($et, $channel, [EX_BRIGHT], $a, [NEG], [NEGF], [NEGF]);
	return();
}


/* in "a" frames, change the bullet angle to "r" and bullet speed to "s" minus original speed (regardless of initial angle) */
/* I swapped "s" and "r" here to match the order of angle, speed arguments of other instructions */
sub Et_exVelTimeSet(et channel slot a s r) { 
	var;
	Et_transformSet($et, $slot, $channel, [EX_VELTIME], $a, [NEG], %r, %s);
	return();
}

sub Et_exVelTime(et channel a s r) {
	var;
	Et_transformPush($et, $channel, [EX_VELTIME], $a, [NEG], %r, %s);
	return();
}


/* in "a" frames using mode "b", the bullet changes size from "r" to "s". */
sub Et_exSizeSet(et channel slot a b r s) { 
	var;
	Et_transformSet($et, $slot, $channel, [EX_SIZE], $a, $b, %r, %s);
	return();
}

sub Et_exSize(et channel a b r s) {
	var;
	Et_transformPush($et, $channel, [EX_SIZE], $a, $b, %r, %s);
	return();
}


/* save current angle from the bullet to the player, to be used with EX_ANGLE c=2 (ANGLE_SAVED constant) */
sub Et_exSaveAngleSet(et channel slot) { 
	var;
	Et_transformSet($et, $slot, $channel, [EX_SAVEANGLE], [NEG], [NEG], [NEGF], [NEGF]);
	return();
}

sub Et_exSaveAngle(et channel) {
	var;
	Et_transformPush($et, $channel, [EX_SAVEANGLE], [NEG], [NEG], [NEGF], [NEGF]);
	return();
}


/* execute the sub set by ins_640 (Et_setExSub) earlier, if ins_640 wasn't used the game explodes */
sub Et_exSpecialSet(et channel slot) { 
	var;
	Et_transformSet($et, $slot, $channel, [EX_SPECIAL], [NEG], [NEG], [NEGF], [NEGF]);
	return();
}

sub Et_exSpecial(et channel) {
	var;
	Et_transformPush($et, $channel, [EX_SPECIAL], [NEG], [NEG], [NEGF], [NEGF]);
	return();
}


/* change the layer of the bullet to "a" */
sub Et_exLayerSet(et channel slot a) { 
	var;
	Et_transformSet($et, $slot, $channel, [EX_LAYER], $a, [NEG], [NEGF], [NEGF]);
	return();
}

sub Et_exLayer(et channel a) {
	var;
	Et_transformPush($et, $channel, [EX_LAYER], $a, [NEG], [NEGF], [NEGF]);
	return();
}


/* set the delay before the bullet spawns to "a", for example if a=60, the bullet will appear 1 second after calling ins_601 (Et_shoot) */
sub Et_exDelaySet(et channel slot a) { 
	var;
	Et_transformSet($et, $slot, $channel, [EX_DELAY], $a, [NEG], [NEGF], [NEGF]);
	return();
}

sub Et_exDelay(et channel a) {
	var;
	Et_transformPush($et, $channel, [EX_DELAY], $a, [NEG], [NEGF], [NEGF]);
	return();
}



/* shoot a laser, I don't know how this one works yet, requires use of one of the earlier transform types too */
sub Et_exLaserSet(et channel slot a b c d r s m n) {
	var;
	Et_transformSet2($et, $slot, $channel, [EX_LASER], $a, $b, $c, $d, %r, %s, %m, %n);
	return();
}

sub Et_exLaser(et channel a b c d r s m n) {
	var;
	Et_transformPush2($et, $channel, [EX_LASER], $a, $b, $c, $d, %r, %s, %m, %n);
	return();
}



/* set bullet hitbox, 0.0f no hitbox, -1.0f restore original hitbox, please do not use this to make EoSD mentos */
sub Et_exHitboxSet(et channel slot r) { 
	var;
	Et_transformSet($et, $slot, $channel, [EX_HITBOX], [NEG], [NEG], %r, [NEGF]);
	return();
}

sub Et_exHitbox(et channel r) {
	var;
	Et_transformPush($et, $channel, [EX_HITBOX], [NEG], [NEG], %r, [NEGF]);
	return();
}


/* wait "a" frames before moving on to the next transform */
sub Et_exWaitSet(et channel slot a) { 
	var;
	Et_transformSet($et, $slot, $channel, [EX_WAIT], $a, [NEG], [NEGF], [NEGF]);
	return();
}

sub Et_exWait(et channel a) {
	var;
	Et_transformPush($et, $channel, [EX_WAIT], $a, [NEG], [NEGF], [NEGF]);
	return();
}